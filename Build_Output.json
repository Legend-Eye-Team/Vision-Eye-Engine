[
    {
        "Name": "Display.py",
        "Content": "PUBLISH_MODULE_DISPLAY = {\n    \"Module\":\"Display\",\n    \"Coder\":[\"QuangDeNhi\"],\n    \"Target\":\"Init and Control Game\"\n}\n\nimport pygame\nfrom. import Setting\nfrom. import Event\n\nclass Display:\n    pygame.init()\n    def __init__(self,width,height,caption) -> None:\n        self._ = pygame.display.set_mode((width,height))\n        pygame.display.set_caption(caption)\n        self.width = width\n        self.height = height\n        self.caption = caption\n\n        self.Enable = True\n\n        self.Clock = pygame.time.Clock()\n\n        self.Graphics = []\n        self.Effects = []\n        self.EventControl = Event.Event_Controller()\n\n        self.setting = Setting.Setting()\n\n    \n    def FillDisplay(self,r:int,g:int,b:int):\n        self._.fill((r,g,b))\n\n    def Input(self):\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                self.Exit()\n        self.EventControl.Update()\n    \n    def Render(self):\n        if self.Enable == False: pygame.quit();return\n        for graphic in self.Graphics:\n            graphic.Render()\n        for effect in self.Effects:\n            effect.Render()\n        pygame.display.update()\n\n    def Exit(self):\n        self.Enable = False\n\n    def Update(self):\n        self.Clock.tick(self.setting.fps)\n        for graphic in self.Graphics:\n            graphic.Update()\n        for effect in self.Effects:\n            effect.Update()"
    },
    {
        "Name": "Effect.py",
        "Content": "PUBLISH_MODULE_EFFECT = {\n    \"Module\":\"Effect\",\n    \"Coder\":[\"QuangDeNhi\"],\n    \"Target\":\"Create Effect\"\n}\n\nimport pygame, random\nfrom . import Vector\nfrom .Human import IS_DIED,IS_LIVE\n\n\ndef MoveParticle(effect):\n    direction =  effect.direction.getVec()\n    effect.x += direction[0]\n    effect.y += direction[1]\n    effect.timeLife -= effect.KillSpeed\n    effect.size -= effect.KillSpeed\n    # Testing ...\n    # particle[1][1] +=\n\nclass Particle:\n    def __init__(self,x,y,direction:Vector.Vector2,timeLife,color) -> None:\n        self.x = x\n        self.y = y\n        self.direction = direction\n        self.timeLife = timeLife\n        self.size = self.timeLife\n        self.color = color\n        self.KillSpeed = 2 / 60 # 60 is fps\n\n        self.move = MoveParticle\n\n        self.alpha = 255\n\n    def MakeSurface(self):\n        radius = self.size * 2\n        surface =  pygame.Surface((radius*2,radius*2)).convert_alpha()\n        pygame.draw.circle(surface,self.color,(radius,radius),radius)\n        surface.set_colorkey((0,0,0))\n        surface.set_alpha(self.alpha)\n        return surface\n\n    def Update(self):\n        self.move(self)\n\n    def Draw(self,display):\n        # pygame.draw.circle(display._,self.color,(self.x,self.y),self.size)\n        surf = self.MakeSurface()\n        display._.blit(surf,(self.x,self.y))\n        if self.timeLife <= 0 or self.alpha <= 0:\n            return IS_DIED\n        return IS_LIVE\n\n\n\nclass ParticleGroup:\n    def __init__(self,display,x,y,\n        direction = Vector.Vector2(random.randint(0,20)/10-1,-4)) -> None:\n\n        self.group = []\n        self.x = x\n        self.y = y\n        \n        self.direction = direction\n\n        self.timeLife_perP = 10\n        self.Enable = True\n        self.color = (255,255,255)\n\n        self.display = display\n        self.display.Effects.append(self)\n\n        self.updateAtt = None\n        self.updateParticle = None\n\n    def CreateNew(self):\n        if self.notEnable(): return\n        # self.group.append([[self.x,self.y],[self.move.getVec()],\n        #               self.timeLife_perP, self.color] )\n        particle = Particle(self.x,self.y,self.direction,self.timeLife_perP,self.color)\n        if self.updateParticle:\n            particle.move = self.updateParticle\n        self.group.append(particle)\n\n    def Update(self):\n        if self.notEnable(): return\n        if self.updateAtt:\n            self.updateAtt()\n        else:\n            self.UpdateAttribute()\n        self.CreateNew()\n        for particle in self.group:\n            particle.move(particle)\n\n    def Render(self):\n        if self.notEnable(): return\n        for particle in self.group:\n            status = particle.Draw(self.display)\n            if status == IS_DIED:\n                self.group.remove(particle)\n    \n    def UpdateAttribute(self):\n        self.direction = Vector.Vector2(random.randint(0,20)/10-1,-4)\n        self.timeLife_perP = random.randint(6,10)\n        \n    \n    def notEnable(self):\n        return self.Enable != True\n\n    def Destroy(self):\n        self = None"
    },
    {
        "Name": "Event.py",
        "Content": "PUBLISH_MODULE_EVENT = {\n    \"Module\":\"Event\",\n    \"Coder\":[\"QuangDeNhi\"],\n    \"Target\":\"Listen to Event\"\n}\n\nimport pygame\n\nclass Event_Controller:\n    def __init__(self) -> None:\n        self.Mouse = Mouse()\n        self.Keyboard = Keyboard()\n    \n    def Update(self):\n        self.Mouse.Update()\n        self.Keyboard.Update()\n\nclass Mouse:\n    def __init__(self) -> None:\n        self.x = self.y = 0\n        self.IsClick = []\n\n    def Update(self):\n        self.x,self.y = pygame.mouse.get_pos()\n        self.IsClick = pygame.mouse.get_pressed()\n    \n    def LeftClick(self):\n        return self.IsClick[0]\n    \n    def MidClick(self):\n        return self.IsClick[1]\n    \n    def RightClick(self):\n        return self.IsClick[2]\n\n    def GetPosition(self):\n        return self.x,self.y\n\nclass Keyboard:\n    def __init__(self) -> None:\n        self.key_pressing = []\n\n    def Update(self):\n        self.key_pressing = pygame.key.get_pressed()\n\n    def IsPress(self,key):\n        return self.key_pressing[key]"
    },
    {
        "Name": "Functional.py",
        "Content": "PRIVATE_MODULE_FUNCTIONAL = {\n    \"Module\":\"Functional\",\n    \"Coder\":[\"QuangDeNhi\"],\n    \"Target\":\"Create short Method for Local\"\n}\n\nimport threading\nimport time\n\n\nstart_id = 0\ndef CreateID():\n    global start_id\n    start_id += 1\n    return start_id - 1\n\nstart_id_gui = 0\ndef CreateGuiID():\n    global start_id_gui\n    start_id_gui -= 1\n    return start_id_gui\n\ndef ConvertBoolean(value):\n    return not value\n\ndef WaitThread(wait_time,todo,exit_do=None):\n    \n    def f(wt):\n        time.sleep(wt)\n        todo()\n    thread = threading.Thread(target=f,args=(wait_time,))\n    thread.start()\n    if exit_do != None: exit_do()"
    },
    {
        "Name": "Graphic.py",
        "Content": "PUBLISH_MODULE_GRAPHIC = {\n    \"Module\":\"Graphic\",\n    \"Coder\":[\"QuangDeNhi\"],\n    \"Target\":\"Create Graphic Object\"\n}\n\nimport pygame\nfrom . import Human\nfrom .Functional import CreateID\n\nTOP_COLLIED = 501\nBOTTOM_COLLIED = 502\nLEFT_COLLIED = 503\nRIGHT_COLLIED = 504\nNONE_COLLIED = 500\n\nSETTING_ARG_GRAPHIC = 101\n\ndef NoneFunction(graphic):\n    return\n\nclass Graphic:\n    def __init__(self,display,x,y) -> None:\n        self.id = CreateID()\n        self.x = x\n        self.y = y\n        self.width = 0\n        self.height = 0\n        self.center = (self.x,self.y)\n        self.alpha = 255\n        self.display = display\n        self.display.Graphics.append(self)\n\n        self.Lock = False\n        self.canCollied = True\n\n        self.updateFunc = NoneFunction\n\n    def Destroy(self):\n        try:\n            self.display.Graphics.remove(self)\n        except ValueError:\n            pass\n        #  self = None\n    \n    def setPoint(self,x,y):\n        self.x = x\n        self.y = y\n    \n    def getId(self):\n        return self.id\n\n    def Update(self):\n        self.center = (self.x+self.width/2,self. y+self.height/2)\n        self.updateFunc(self)\n\nclass Rectangle(Graphic):\n    def __init__(self, display, x, y,width,height) -> None:\n        super().__init__(display, x, y)\n        self.width = width\n        self.height = height\n        self.color = (200,200,200)\n        self.Attribute = {\n            \"IsFlat\":False,\n            \"IsImage\":False\n        }\n        self.setting = self.display.setting\n\n    def SetAttribute(self, name:str, value):\n        self.Attribute[name] = value\n        self.UpdateOnce()\n\n    def GetAttribute(self, name:str):\n        return self.Attribute[name]\n\n    def Transform(self,new_width:int,new_height:int):\n        self.width = new_width\n        self.height = new_height\n\n    def GetCollied(self,graphic:Graphic,max_speed:int):\n        if graphic.canCollied == True:\n\n            local_rect = pygame.Rect(self.x,self.y,self.width,self.height)\n            other_rect = pygame.Rect(graphic.x,graphic.y,graphic.width,graphic.height)\n\n            if local_rect.colliderect(other_rect):\n                if abs(other_rect.top - local_rect.bottom) < max_speed*2 :\n                    return (TOP_COLLIED,other_rect.top)\n                if abs(other_rect.bottom - local_rect.top) < max_speed*2 :\n                    return (BOTTOM_COLLIED, other_rect.top)\n                if abs(other_rect.right - local_rect.left) < max_speed*2 :\n                    return (RIGHT_COLLIED, other_rect.left)\n                if abs(other_rect.left - local_rect.right) < max_speed*2 :\n                    return (LEFT_COLLIED, other_rect.right)\n            return (NONE_COLLIED,None)\n\n    def isTouched(self,human):\n        rect = human\n        \n        local_rect = pygame.Rect(self.x,self.y,self.width,self.height)\n        # print(local_rect.collidepoint(rect.center))\n        if local_rect.collidepoint(rect.center)              or \\\n            local_rect.collidepoint(rect.x,rect.y+rect.height) or \\\n            local_rect.collidepoint(rect.x+rect.width,rect.y ):\n            return True\n        else:\n            return False\n\n    def GravityUpdate(self):\n        if self.Lock == False:\n            self.y += self.setting.gravity\n\n    def Update(self):\n        self.GravityUpdate()\n        for graphic in self.display.Graphics:\n            if self.Lock == False:\n                a = self.GetCollied(graphic,self.display.setting.gravity)\n                if a == None: continue\n                if a[0] == TOP_COLLIED:\n                    self.y = a[1] - self.height\n        return super().Update()\n\n    def UpdateOnce(self):\n        if self.Attribute[\"IsFlat\"] == True:\n            self.Transform(self.display._.get_width(),100)\n            self.x = 0\n            self.y = self.display._.get_height()\n            self.Lock = True\n\n    def MakeSurface(self):\n        surface = pygame.Surface((self.width,self.height)).convert_alpha()\n        pygame.draw.rect(surface,self.color,(0,0,self.width,self.height))\n        surface.set_colorkey((0,0,0))\n        surface.set_alpha(self.alpha)\n        return surface\n\n    def Render(self):\n        # local_rect = pygame.Rect(self.x,self.y,self.width,self.height)\n        # pygame.draw.rect(self.display._,self.color,local_rect)\n        rect = self.MakeSurface()\n        self.display._.blit(rect,(self.x,self.y))"
    },
    {
        "Name": "Gui.py",
        "Content": "PUBLISH_MODULE_GUI = {\n    \"Module\":\"Gui\",\n    \"Coder\":[\"QuangDeNhi\"],\n    \"Target\":\"Create Gui for Client\"\n}\n\nimport pygame\nfrom .Functional import CreateGuiID\n\nclass Text:\n    def __init__(self,display,font,size,text,x,y) -> None:\n        self.id = CreateGuiID()\n        self.font = pygame.font.Font(font,size)\n        self.content = text\n        self.color_text = (255,255,255)\n        self.label = self.font.render(self.content,True,self.color_text)\n        self.textRect = self.label.get_rect()\n        self.display = display\n        self.display.Graphics.append(self)\n        self.x = x\n        self.y = y\n        self.size = size\n\n        self.canCollied = False\n\n    def Destroy(self):\n        self = None\n\n    def Render(self):\n        self.display._.blit(self.label,(self.x,self.y))\n    \n    def Update(self):\n        self.label = self.font.render(self.content,True,self.color_text)\n\nclass Button(Text):\n    def __init__(self, display, font, size_text, text,x,y,width,height) -> None:\n        super().__init__(display,font,size_text,text,x,y)\n        self.color_background = (255,255,255)\n        self.color_text = (0,0,0)\n        self.width = width\n        self.height = height\n        self.isPressing = None\n        self.func = None\n\n    def Render(self):\n        pygame.draw.rect(self.display._,self.color_background,(self.x-self.size/2,self.y-self.size/2,self.width,self.height))\n        return super().Render()\n\n    def Update(self):\n        self.isPressing = self.IsPress()\n        return super().Update()\n\n    def initFunction(self,func):\n        self.func = func\n\n    def activeFunction(self):\n        if self.func != None:\n            self.func()\n\n    def IsPress(self):\n        mouse_data = self.display.EventControl.Mouse\n\n        if mouse_data.LeftClick():\n            x,y = mouse_data.GetPosition()\n            rect = pygame.Rect(self.x,self.y,self.width,self.height)\n            if rect.collidepoint(x,y):\n                if self.isPressing == True:\n                    self.activeFunction()\n                return True\n            return False\n        return False"
    },
    {
        "Name": "Human.py",
        "Content": "INFO_MODULE_HUMAN = {\n    \"Module\":\"Human\",\n    \"Coder\":[\"QuangDeNhi\"]\n}\n\nfrom . import Functional\n# from . import Rectangle\nimport threading,time\n\nTOP_COLLIED = 501\nBOTTOM_COLLIED = 502\nLEFT_COLLIED = 503\nRIGHT_COLLIED = 504\nNONE_COLLIED = 500\nIS_LIVE = 510\nIS_DIED = 511\n\nclass Human:\n    def __init__(self,Rectangle) -> None:\n        self.Rectangle = Rectangle\n        self.Health = 100\n        self.Max_health = 100\n\n        self.Jump_power = 120\n        self._CanJump = True\n        self._countdownJump = .7\n\n        self.walkSpeed = 2\n\n    def MoveTo(self,dir_=1):\n        will_x = self.Rectangle.x \n        speed = self.walkSpeed * dir_\n        will_x += speed\n        \n        for graphic in self.Rectangle.display.Graphics:\n            a = self.Rectangle.GetCollied(graphic,abs(self.walkSpeed))\n            if a == None: continue\n            elif a[0] == LEFT_COLLIED and speed> 0:\n                if graphic.Lock == True: return\n                elif graphic.Lock == False:\n                    graphic.x += speed\n                    will_x = speed\n                    return\n\n            elif a[0] == RIGHT_COLLIED and speed < 0:\n                if graphic.Lock == True: return\n                elif graphic.Lock == False:\n                    graphic.x += speed\n                    will_x = speed\n                    return\n\n        \n        self.Rectangle.x = will_x\n    \n    def Move2D(self,dir_x=0,dir_y=0):\n        will_x = self.Rectangle.x \n        speed = self.walkSpeed * dir_x\n        will_x += speed\n\n        will_y = self.Rectangle.y\n        speed2 = self.walkSpeed * dir_y\n        will_y += speed2\n        \n        for graphic in self.Rectangle.display.Graphics:\n            a = self.Rectangle.GetCollied(graphic,abs(self.walkSpeed))\n            if a == None: continue\n            elif a[0] == LEFT_COLLIED and speed> 0 or \\\n                a[0] == RIGHT_COLLIED and speed < 0:\n                if graphic.Lock == True: return\n                elif graphic.Lock == False:\n                    graphic.x += speed\n                    will_x = speed\n                    return\n\n            elif a[0] == TOP_COLLIED and speed < 0 or \\\n                a[0] == BOTTOM_COLLIED and speed < 0:\n                if graphic.Lock == True: return\n                elif graphic.Lock == False:\n                    graphic.y += speed\n                    will_y = speed\n                    return\n\n        self.Rectangle.x = will_x\n        self.Rectangle.y = will_y\n\n    def _Jump(self,_):\n        self._CanJump = False\n        self.Rectangle.Lock= True\n        for i in  range(0,5):\n            self.Rectangle.y -= self.Jump_power / 5\n            time.sleep(.02)\n        self.Rectangle.Lock= False\n\n    def JumpActive(self):\n        if self._CanJump == True:\n            f =threading.Thread(target=self._Jump,args=(1,))\n            f.start()\n            def convert(): self._CanJump = True\n            Functional.WaitThread(self._countdownJump,convert)\n\n    def TakeHealth(self,damage):\n        self.Health -= damage"
    },
    {
        "Name": "Image.py",
        "Content": "INFO_MODULE_IMAGE = {\n    \"Module\":\"Graphic-Image\",\n    \"Coder\":[\"QuangDeNhi\"]\n}\n\nimport pygame\nfrom . import Rectangle\n\nclass Image(Rectangle):\n    def __init__(self, display, x, y,source) -> None:\n        self.image = pygame.image.load(source).convert()\n        self.width = self.image.get_width()\n        self.height = self.image.get_height()\n        super().__init__(display, x, y,self.width,self.height)\n        self.SetAttribute(\"IsImage\",True)\n\n    def MakeSurface(self):\n        surface = pygame.Surface((self.width,self.height)).convert_alpha()\n        # pygame.draw.rect(surface,self.color,(0,0,self.width,self.height))\n        pic = self.image.copy()\n        surface.blit(pic,(0,0))\n        pic = pygame.PixelArray(pic)\n        # self.image = pygame.PixelArray(self.image)\n        surface.set_colorkey((0,0,0))\n        surface.set_alpha(self.alpha)\n        return surface\n\n    def Render(self):\n        rect = self.MakeSurface()\n        self.display._.blit(rect,(self.x,self.y))\n        rect = pygame.PixelArray(rect)\n    \n    def Transform(self,new_width:int,new_height:int):\n        self.image = pygame.transform.scale(self.image,(new_width,new_height))\n        self.UpdateImage()\n    \n    def UpdateImage(self):\n        self.width = self.image.get_width()\n        self.height = self.image.get_height()\n"
    },
    {
        "Name": "Math.py",
        "Content": "import math\nfrom .Graphic import Graphic\nfrom .Vector import Vector2\n\ndef getDistance(graphic1:Graphic,  graphic2:Graphic|Vector2):\n    distance = 0\n    if type(graphic2) == Vector2:\n        dx =  graphic2.x - graphic1.x\n        dy =  graphic2.y - graphic1.y\n        distance = math.sqrt(dx**2 + dy**2)\n    else:\n        dx =  graphic2.center[0] - graphic1.x\n        dy =  graphic2.center[1] - graphic1.y\n        distance = math.sqrt(dx**2 + dy**2)\n    return distance\n\ndef getDirection(graphic1:Graphic,  graphic2:Graphic|Vector2):\n    norm = getDistance(graphic1,graphic2)\n\n    if type(graphic2) == Graphic:\n        vec = Vector2(graphic2.center[0] - graphic1.center[0], graphic2.center[1] - graphic1.center[1])\n        direction = Vector2(vec.x / (norm+0.1),vec.y / (norm+0.1))\n        return direction \n    elif type(graphic2) == Vector2:\n        vec = Vector2(graphic2.x - graphic1.center[0], graphic2.y - graphic1.center[1])\n        direction = Vector2(vec.x / (norm+0.1),vec.y / (norm+0.1))\n        return direction "
    },
    {
        "Name": "Setting.py",
        "Content": "PRIVATE_MODULE_SETTING = {\n    \"Module\":\"Setting\",\n    \"Coder\":[\"QuangDeNhi\"],\n    \"Target\":\"Setting for Client\"\n}\n\nclass Setting:\n    def __init__(self) -> None:\n        self.gravity = 3\n        self.fps = 60"
    },
    {
        "Name": "Vector.py",
        "Content": "PUBLISH_MODULE_VECTOR = {\n    \"Module\":\"Vector\",\n    \"Coder\":[\"QuangDeNhi\"],\n    \"Target\":\"Create Datatype\"\n}\n\nclass Vector2:\n    def __init__(self,x:float,y:float) -> None:\n        self.x = x\n        self.y = y\n    \n    def getVec(self):\n        return (self.x,self.y)"
    },
    {
        "Name": "__init__.py",
        "Content": "from .Display import *\nfrom .Graphic import *\nfrom . import Image\nfrom . import Gui\nfrom . import Human\nfrom . import Vector\nfrom . import Effect\nfrom . import Math\n\ndef HelloWorld():\n    print(\"\"\"            ---\nThank You For Using Engine\"\"\")\n\nHelloWorld()\n\nDISPLAY_WIDTH = 500\nDISPLAY_HEIGHT = 500\nDISPLAY_CAPTION = \"Engine Vision Eye\"\n\nHUMAN_DIRECTION_LEFT = -1\nHUMAN_DIRECTION_RIGHT = 1"
    }
]